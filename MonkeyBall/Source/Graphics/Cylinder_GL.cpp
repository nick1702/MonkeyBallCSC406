/*==================================================================================+#																					##	File:		Cylinder_GL.cpp														##																					##	This file implements the Cylinder class (OpenGL version).						##																					##																					##-----------------------------------------------------------------------------------##	Author:			jean-yves herve', Dept of CS, U. of Rhode Island and			##					GRPR, Ecole Polytechnique de Montreal							##																					##	Date Creation:	May 2001														##																					##	Modifications:																	##																					#+==================================================================================*/#include <math.h>#include <stdlib.h>////#include "errorHandling.h"#include "graphicsDef.h"#include "Cylinder_GL.h"//	Redefinition of the class' static elements//bool Cylinder_GL::initCtSt = initStatic();GLfloat Cylinder_GL::ct[kVeryHighDefCircPts],		Cylinder_GL::st[kVeryHighDefCircPts];////==================================================================================//	Cylinder_GL constructors and destructor//==================================================================================/*----------------------------------------------------------------------------------+|	Constructor:	Cylinder_GL(GLfloat *origin, GLfloat **axes, bool isClosed)		||																					||	Parameters:		origin		coordinates of the origin (bottom' center)			||					axes		coordinates of the major axis, minor axis, and 		||									direction axis in a 3x3 0-based array.			||					isClosed	should the top and bottom faces be drawn?			||																					||	Description:	Allocates the vertex and normal arrays, then invokes the 		||					init() method	to initialize these arrays.						|+----------------------------------------------------------------------------------*/Cylinder_GL::Cylinder_GL(GLfloat *origin, GLfloat **axes, bool isClosed){	short		i;		//	Allocate the arrays of vertices and normal vectors	vertex = new GLfloat **[kVeryHighDefSlabs+1];	normal = glfMatrix(0, kVeryHighDefCircPts-1, 0, 2);		if (vertex==NULL)		handleError(kOpenGLNumAllocError, "Error while allocating array of GL numbers");	for (i=0; i<=kVeryHighDefSlabs; i++)		vertex[i] = glfMatrix(0, kVeryHighDefCircPts-1, 0, 2);		closedCyl = isClosed;		//	initialize at medium and fine (not finest) resolution	setResolution(kFineResolution, kMediumResolution);		init(origin, axes);}/*----------------------------------------------------------------------------------+|	Constructor:	Cylinder_GL(GLfloat *origin, GLfloat *dirAxis, GLfloat radius,	||									bool isClosed)									||																					||	Parameters:		origin		coordinates of the origin (bottom' center)			||					dirAxis		coordinates of the cylinder's axis.					||					radius		the cylinder's radius								||					isClosed	should the top and bottom faces be drawn?			||																					||	Description:	Allocates the vertex and normal arrays, then invokes the 		||					init() method	to initialize these arrays.						|+----------------------------------------------------------------------------------*/Cylinder_GL::Cylinder_GL(GLfloat *origin, GLfloat *dirAxis, GLfloat radius,	bool isClosed){	short		i;	GLfloat		**axes, w[3];		axes = glfMatrix(0, 2, 0, 2);	//		//	dirAxis is the direction axis of the cylinder	axes[2][0] = dirAxis[0];	axes[2][1] = dirAxis[1];	axes[2][2] = dirAxis[2]; 	//	//	For the major axis, we need to build a vector orthogonal to dirAxis.	if ((dirAxis[0]!= 0.f) || (dirAxis[2]!= 0.f))	//	this is not the local Y axis	{		w[0] = 0.f; w[1] = 1.f; w[2] = 0.f;		commonNormalVector(w, dirAxis, axes[0]);		//	"X" = "Y" x "Z"		commonNormalVector(dirAxis, axes[0], axes[1]); 	//	"Y" = "Z" x "X"		//		//	and now we can multiply by the radius		for (i=0; i<3; i++)		{			axes[0][i] *= radius;			axes[1][i] *= radius;		}	}	//	if dirAxis was the local Y axis, then I can take Z and X as major and minor	else	{		axes[0][0] = axes[0][1] = axes[1][1] = axes[1][2] = 0.f;		axes[0][2] = axes[1][0] = radius;	}		//	Allocate the arrays of vertices and normal vectors	vertex = new GLfloat **[kVeryHighDefSlabs+1];	normal = glfMatrix(0, kVeryHighDefCircPts-1, 0, 2);		if (vertex==NULL)		handleError(kOpenGLNumAllocError, "Error while allocating array of GL numbers");	for (i=0; i<=kVeryHighDefSlabs; i++)		vertex[i] = glfMatrix(0, kVeryHighDefCircPts-1, 0, 2);		closedCyl = isClosed;	//	initialize at medium and fine (not finest) resolution	setResolution(kFineResolution, kMediumResolution);		init(origin, axes);		free_glfMatrix(axes, 0, 2, 0, 2);}/*----------------------------------------------------------------------------------+|	Destructor:		Cylinder_GL(void)												||																					||	Parameters:		None															||																					||	Description:	Frees all the arrays that were allocated at the creation.		|																|+----------------------------------------------------------------------------------*/Cylinder_GL::~Cylinder_GL(void){	short i;		if (vertex!=NULL)	{		for (i=0; i<=kVeryHighDefSlabs; i++)			free_glfMatrix(vertex[i], 0,  kVeryHighDefCircPts-1, 0, 2);		delete [] vertex;		vertex = NULL;	}	if (normal!=NULL)	{		free_glfMatrix(normal, 0,  kVeryHighDefCircPts-1, 0, 2);		normal = NULL;	}}//==================================================================================//	Cylinder_GL public methods//==================================================================================#pragma mark -/*----------------------------------------------------------------------------------+|	Function:		void setResolution(ResolutionLevel res)							||																					||	Status:			Public															||																					||	Parameters:		res:		desired resolution									||																					||	Returns:		Nothing															||																					||	Description:	Adjusts private variables for proper display of the cylinder	||																					|+----------------------------------------------------------------------------------*/void Cylinder_GL::setResolution(ResolutionLevel res){	setResolution(res, res);}/*----------------------------------------------------------------------------------+|	Function:		void setResolution(ResolutionLevel circRes,					||										ResolutionLevel slabRes)					||																					||	Status:			Public															||																					||	Parameters:		circRes:	desired nb of points on a circle					||					slabRes:	desired slab resolution level						||																					||	Returns:		Nothing															||																					||	Description:	Adjusts private variables for proper display of the cylinder	||																					|+----------------------------------------------------------------------------------*/void Cylinder_GL::setResolution(ResolutionLevel circRes, ResolutionLevel slabRes){	switch (circRes)	{		case kVeryHighResolution:			circStep = 1;			break;					case kFineResolution:			circStep = kFineDefCircScale;			break;					case kMediumResolution:			circStep = kMediumDefCircScale;			break;					case kCoarseResolution:			circStep = kCoarseDefCircScale;			break;					case kVeryLowResolution:			circStep = kVeryLowDefCircScale;			break;					default:			circStep = kMediumDefCircScale;			break;	}		switch (slabRes)	{		case kVeryHighResolution:			slabStep = 1;			break;					case kFineResolution:			slabStep = kFineDefSlabScale;			break;					case kMediumResolution:			slabStep = kMediumDefSlabScale;			break;					case kCoarseResolution:			slabStep = kCoarseDefSlabScale;			break;					case kVeryLowResolution:			slabStep = kVeryLowDefSlabScale;			break;					default:			slabStep = kMediumDefSlabScale;			break;	}}/*----------------------------------------------------------------------------------+|	Function:		void draw(void)													||																					||	Status:			Public															||																					||	Parameters:		None															||																					||	Returns:		Nothing															||																					||	Description:	Draws the cylinder												||																					|+----------------------------------------------------------------------------------*/void Cylinder_GL::draw(void){	short	i, j;		GraphicObject_GL::draw();		//	I draw the cylinders as a series of one-slab-high crowns	//	Each crown is defined as a quad strip.	//	It might be a better idea to draw then the other way around (as a ring	//	of linear quad strips).  --> check 	for (i=0; i<=kVeryHighDefSlabs-slabStep; i+=slabStep)	{		glBegin(GL_QUAD_STRIP);//		glBegin(GL_TRIANGLE_STRIP);			for (j=0; j<kVeryHighDefCircPts; j+=circStep)			{				glNormal3fv(normal[j]);				glVertex3fv(vertex[i+slabStep][j]);				glNormal3fv(normal[j]);				glVertex3fv(vertex[i][j]);			}			glNormal3fv(normal[0]);			glVertex3fv(vertex[i+slabStep][0]);			glNormal3fv(normal[0]);			glVertex3fv(vertex[i][0]);					glEnd();	}		//	If this is a closed cylinder, then we also draw the top and bottom	//	sides at the same resolution as the rest)	if (closedCyl)	{		glNormal3fv(normalTop);		glBegin(GL_POLYGON);			for (j=0; j<kVeryHighDefCircPts; j+=circStep)				glVertex3fv(vertex[kVeryHighDefSlabs][j]);		glEnd();		//		glNormal3fv(normalBottom);		glBegin(GL_POLYGON);			for (j=kVeryHighDefCircPts-circStep; j>=0; j-=circStep)				glVertex3fv(vertex[0][j]);		glEnd();	}}//==================================================================================//	Cylinder_GL private methods//==================================================================================#pragma mark -/*----------------------------------------------------------------------------------+|	Function:		void init(GLfloat *origin, GLfloat **a)							||																					||	Status:			Public															||																					||	Parameters:		origin		coordinates of the origin (bottom' center)			||					a			coordinates of the major axis, minor axis, and 		||									direction axis in a 3x3 0-based array.			||																					||	Returns:		Nothing															||																					||	Description:	Initializes the array of vertex and normal coordinates			||																					|+----------------------------------------------------------------------------------*/void Cylinder_GL::init(GLfloat *origin, GLfloat **a){	short	i, j, k;	GLfloat	dirStep = 1./kVeryHighDefSlabs,			dir[kVeryHighDefSlabs+1][3],			//	X, Y, and Z coordinates of the radial and normal directions.			radial_j[3],			majCross[3], minCross[3];				//	majCross = a[0] x a[2] (major axis x direction)	crossProduct(a[0], a[2], majCross);	//	minCross = a[1] x a[2] (minor axis x direction)	crossProduct(a[1], a[2], minCross);	//	First, we precompute the graduation steps for the slabs along	//	the "direction" axis (a[2]).	for (i=0; i<=kVeryHighDefSlabs; i++)		for (k=0; k<3; k++)			dir[i][k] = i*dirStep*a[2][k];				for (j=0; j< kVeryHighDefCircPts; j++)	{		for (k=0; k<3; k++)		{			radial_j[k] = ct[j]*a[0][k] + st[j]*a[1][k];			//			normal[j][k] =	ct[j]*minCross[k] - st[j]*majCross[k];		}		normalizeVector(normal[j]);					for (i=0; i<=kVeryHighDefSlabs; i++)			for (k=0; k<3; k++)				//	M = origin + cos[u] major + sin[u] minor + v direction				vertex[i][j][k] = origin[k] + radial_j[k] + dir[i][k];					}		//	if this is a closed cylinder, then we must also compute the normal	//	vector for the top and bottom faces.	if (closedCyl)	{		//	topNormal = major x minor / ||major x minor||		commonNormalVector(a[0], a[1], normalTop);		for (k=0; k<3; k++)			normalBottom[k] = -normalTop[k];	}}/*----------------------------------------------------------------------------------+|	Function:		void initStatic(void)											||																					||	Status:			Public															||																					||	Parameters:		None															||																					||	Returns:		Nothing															||																					||	Description:	Initializes the class (static) sine and cosine value arrays		||																					|+----------------------------------------------------------------------------------*/bool Cylinder_GL::initStatic(void){	GLfloat	dTheta = 2.f*PI/kVeryHighDefCircPts;	for (short j=0; j<kVeryHighDefCircPts; j++)	{		ct[j] = cosf(j*dTheta);		st[j] = sinf(j*dTheta);	}		return true;}