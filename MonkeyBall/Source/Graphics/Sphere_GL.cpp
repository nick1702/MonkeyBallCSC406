/*==================================================================================+#																					##	File:		Sphere_GL.cpp														##																					##	This file implements the Cylinder class (OpenGL version).						##																					##																					##-----------------------------------------------------------------------------------##	Author:			CSC406															##																					##	Date Creation:	Fall 2021														##																					##	Modifications:																	##																					#+==================================================================================*/#include <math.h>#include <stdlib.h>////#include "errorHandling.h"#include "graphicsDef.h"#include "Sphere_GL.h"//	Redefinition of the class' static elements//bool Sphere_GL::initCtSt = initStatic();GLfloat Sphere_GL::ct[kVeryHighDefCircPts],		Sphere_GL::st[kVeryHighDefCircPts];////==================================================================================//	Sphere_GL constructors and destructor//==================================================================================/*----------------------------------------------------------------------------------+|	Constructor:	Sphere_GL(GLfloat *origin, GLfloat **axes, bool isClosed)		||																					||	Parameters:		origin		coordinates of the origin (bottom' center)			||					axes		coordinates of the major axis, minor axis, and 		||									direction axis in a 3x3 0-based array.			||					isClosed	should the top and bottom faces be drawn?			||																					||	Description:	Allocates the vertex and normal arrays, then invokes the 		||					init() method	to initialize these arrays.						|+----------------------------------------------------------------------------------*/Sphere_GL::Sphere_GL(GLfloat*origin, GLfloat radius){//	for (int i=0; i<=kVeryHighDefSlabs; i++)//		vertex[i] = glfMatrix(0, kVeryHighDefCircPts-1, 0, 2);//	//	initialize at medium and fine (not finest) resolution	setResolution(kFineResolution, kMediumResolution);		init(origin, radius);}/*----------------------------------------------------------------------------------+|	Destructor:		Sphere_GL(void)												||																					||	Parameters:		None															||																					||	Description:	Frees all the arrays that were allocated at the creation.		|																|+----------------------------------------------------------------------------------*/Sphere_GL::~Sphere_GL(void){	if (vertex!=NULL)	{//		for (int i=0; i<=kVeryHighDefSlabs; i++)//			free_glfMatrix(vertex[i], 0,  kVeryHighDefCircPts-1, 0, 2);//		delete [] vertex;//		vertex = NULL;	}	if (normal!=NULL)	{//		free_glfMatrix(normal, 0,  kVeryHighDefCircPts-1, 0, 2);//		normal = NULL;	}}//==================================================================================//	Sphere_GL public methods//==================================================================================#pragma mark -/*----------------------------------------------------------------------------------+|	Function:		void setResolution(ResolutionLevel res)							||																					||	Status:			Public															||																					||	Parameters:		res:		desired resolution									||																					||	Returns:		Nothing															||																					||	Description:	Adjusts private variables for proper display of the cylinder	||																					|+----------------------------------------------------------------------------------*/void Sphere_GL::setResolution(ResolutionLevel res){	setResolution(res, res);}/*----------------------------------------------------------------------------------+|	Function:		void setResolution(ResolutionLevel circRes,					||										ResolutionLevel slabRes)					||																					||	Status:			Public															||																					||	Parameters:		circRes:	desired nb of points on a circle					||					slabRes:	desired slab resolution level						||																					||	Returns:		Nothing															||																					||	Description:	Adjusts private variables for proper display of the cylinder	||																					|+----------------------------------------------------------------------------------*/void Sphere_GL::setResolution(ResolutionLevel longRes, ResolutionLevel latRes){	switch (longRes)	{		case kVeryHighResolution:			longStep = 1;			break;					case kFineResolution:			longStep = kFineDefCircScale;			break;					case kMediumResolution:			longStep = kMediumDefCircScale;			break;					case kCoarseResolution:			longStep = kCoarseDefCircScale;			break;					case kVeryLowResolution:			longStep = kVeryLowDefCircScale;			break;					default:			longStep = kMediumDefCircScale;			break;	}		switch (latRes)	{		case kVeryHighResolution:			latStep = 1;			break;					case kFineResolution:			latStep = kFineDefSlabScale;			break;					case kMediumResolution:			latStep = kMediumDefSlabScale;			break;					case kCoarseResolution:			latStep = kCoarseDefSlabScale;			break;					case kVeryLowResolution:			latStep = kVeryLowDefSlabScale;			break;					default:			latStep = kMediumDefSlabScale;			break;	}}/*----------------------------------------------------------------------------------+|	Function:		void draw(void)													||																					||	Status:			Public															||																					||	Parameters:		None															||																					||	Returns:		Nothing															||																					||	Description:	Draws the cylinder												||																					|+----------------------------------------------------------------------------------*/void Sphere_GL::draw(void){	short	i, j;		GraphicObject_GL::draw();/*	//	I draw the cylinders as a series of one-slab-high crowns	//	Each crown is defined as a quad strip.	//	It might be a better idea to draw then the other way around (as a ring	//	of linear quad strips).  --> check 	for (i=0; i<=kVeryHighDefSlabs-slabStep; i+=slabStep)	{		glBegin(GL_QUAD_STRIP);//		glBegin(GL_TRIANGLE_STRIP);			for (j=0; j<kVeryHighDefCircPts; j+=circStep)			{				glNormal3fv(normal[j]);				glVertex3fv(vertex[i+slabStep][j]);				glNormal3fv(normal[j]);				glVertex3fv(vertex[i][j]);			}			glNormal3fv(normal[0]);			glVertex3fv(vertex[i+slabStep][0]);			glNormal3fv(normal[0]);			glVertex3fv(vertex[i][0]);					glEnd();	}		//	If this is a closed cylinder, then we also draw the top and bottom	//	sides at the same resolution as the rest)	if (closedCyl)	{		glNormal3fv(normalTop);		glBegin(GL_POLYGON);			for (j=0; j<kVeryHighDefCircPts; j+=circStep)				glVertex3fv(vertex[kVeryHighDefSlabs][j]);		glEnd();		//		glNormal3fv(normalBottom);		glBegin(GL_POLYGON);			for (j=kVeryHighDefCircPts-circStep; j>=0; j-=circStep)				glVertex3fv(vertex[0][j]);		glEnd();	}*/}//==================================================================================//	Sphere_GL private methods//==================================================================================#pragma mark -/*----------------------------------------------------------------------------------+|	Function:		void init(GLfloat *origin, GLfloat **a)							||																					||	Status:			Public															||																					||	Parameters:		origin		coordinates of the origin (bottom' center)			||					a			coordinates of the major axis, minor axis, and 		||									direction axis in a 3x3 0-based array.			||																					||	Returns:		Nothing															||																					||	Description:	Initializes the array of vertex and normal coordinates			||																					|+----------------------------------------------------------------------------------*/void Sphere_GL::init(GLfloat *origin, GLfloat radius){    /*	short	i, j, k;	GLfloat	dirStep = 1./kVeryHighDefSlabs,			dir[kVeryHighDefSlabs+1][3],			//	X, Y, and Z coordinates of the radial and normal directions.			radial_j[3],			majCross[3], minCross[3];				//	majCross = a[0] x a[2] (major axis x direction)	crossProduct(a[0], a[2], majCross);	//	minCross = a[1] x a[2] (minor axis x direction)	crossProduct(a[1], a[2], minCross);	//	First, we precompute the graduation steps for the slabs along	//	the "direction" axis (a[2]).	for (i=0; i<=kVeryHighDefSlabs; i++)		for (k=0; k<3; k++)			dir[i][k] = i*dirStep*a[2][k];				for (j=0; j< kVeryHighDefCircPts; j++)	{		for (k=0; k<3; k++)		{			radial_j[k] = ct[j]*a[0][k] + st[j]*a[1][k];			//			normal[j][k] =	ct[j]*minCross[k] - st[j]*majCross[k];		}		normalizeVector(normal[j]);					for (i=0; i<=kVeryHighDefSlabs; i++)			for (k=0; k<3; k++)				//	M = origin + cos[u] major + sin[u] minor + v direction				vertex[i][j][k] = origin[k] + radial_j[k] + dir[i][k];					}		//	if this is a closed cylinder, then we must also compute the normal	//	vector for the top and bottom faces.	if (closedCyl)	{		//	topNormal = major x minor / ||major x minor||		commonNormalVector(a[0], a[1], normalTop);		for (k=0; k<3; k++)			normalBottom[k] = -normalTop[k];	}*/}/*----------------------------------------------------------------------------------+|	Function:		void initStatic(void)											||																					||	Status:			Public															||																					||	Parameters:		None															||																					||	Returns:		Nothing															||																					||	Description:	Initializes the class (static) sine and cosine value arrays		||																					|+----------------------------------------------------------------------------------*/bool Sphere_GL::initStatic(void){	GLfloat	dTheta = 2.f*PI/kVeryHighDefCircPts;	for (short j=0; j<kVeryHighDefCircPts; j++)	{		ct[j] = cosf(j*dTheta);		st[j] = sinf(j*dTheta);	}		return true;}